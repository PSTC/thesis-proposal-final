@inproceedings{gimenez,
author="Gim{\'e}nez, Eduardo",
editor="Dybjer, Peter and Nordstr{\"o}m, Bengt and Smith, Jan",
title="Codifying guarded definitions with recursive schemes",
booktitle="Types for Proofs and Programs",
year="1995",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="39--59",
abstract="We formalize an extension of the Calculus of Constructions with inductive and coinductive types which allows a more direct description of recursive definitions. The approach we follow is close to the one proposed for Martin-L{\"o}f's type theory in [5]. Recursive objects can be defined by fixed-point definitions as in functional programming languages, and a syntactical checking of these definitions avoids the introduction of non-normalizable terms. We show that the conditions for accepting a recursive definition proposed in [5] are not sufficient for the Calculus of Constructions, and we modify them. As a way of justifying our conditions, we develop a general method to codify a fix point definition satisfying them using well-known recursive schemes, like primitive recursion and co-recursion. We also propose different reduction rules from the ones used in [5] in order to obtain a decidable conversion relation for the system.",
isbn="978-3-540-47770-9"
}

@phdthesis{cic-hat-bar,
  TITLE = {{On type-based termination and dependent pattern matching in the calculus of inductive constructions}},
  AUTHOR = {Sacchini, Jorge Luis},
  URL = {https://pastel.archives-ouvertes.fr/pastel-00622429},
  NUMBER = {2011ENMP0022},
  SCHOOL = {{{\'E}cole Nationale Sup{\'e}rieure des Mines de Paris}},
  YEAR = {2011},
  MONTH = Jun,
  KEYWORDS = {Type-based termination ; d{\'e}pendent types ; pattern matching ; calculus of inductive constructions ; Terminaison bas{\'e}e sur les types ; types d{\'e}pendants ; filtrage par motifs ; calcul des constructions inductives},
  TYPE = {Theses},
  PDF = {https://pastel.archives-ouvertes.fr/pastel-00622429/file/21076_SACCHINI_2011_archivage.pdf},
  HAL_ID = {pastel-00622429},
  HAL_VERSION = {v1},
}

@inproceedings{hughes,
 author = {Hughes, John and Pareto, Lars and Sabry, Amr},
 title = {Proving the Correctness of Reactive Systems Using Sized Types},
 booktitle = {Proceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
 series = {POPL '96},
 year = {1996},
 isbn = {0-89791-769-3},
 location = {St. Petersburg Beach, Florida, USA},
 pages = {410--423},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/237721.240882},
 doi = {10.1145/237721.240882},
 acmid = {240882},
 publisher = {ACM},
 address = {New York, NY, USA},
} 

@InProceedings{cic-hat,
author="Barthe, Gilles
and Gr{\'e}goire, Benjamin
and Pastawski, Fernando",
editor="Hermann, Miki
and Voronkov, Andrei",
title="{CIC}$\widehat{~}$ : Type-Based Termination of Recursive Definitions in the Calculus of Inductive Constructions",
booktitle="Logic for Programming, Artificial Intelligence, and Reasoning",
year="2006",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="257--271",
abstract="Sized types provides a type-based mechanism to enforce termination of recursive definitions in typed $\lambda$-calculi. Previous work has provided strong indications that type-based termination provides an appropriate foundation for proof assistants based on type theory; however, most work to date has been confined to non-dependent type systems. In this article, we introduce a variant of the Calculus of Inductive Constructions with sized types and study its meta theoretical properties: subject reduction, normalization, and thus consistency and decidability of type-checking and of size-inference. A prototype implementation has been developed alongside case studies.",
isbn="978-3-540-48282-6"
}

@InProceedings{f-hat,
author="Barthe, Gilles
and Gr{\'e}goire, Benjamin
and Pastawski, Fernando",
editor="Urzyczyn, Pawe{\l}",
title="Practical Inference for Type-Based Termination in a Polymorphic Setting",
booktitle="Typed Lambda Calculi and Applications",
year="2005",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="71--85",
abstract="We introduce a polymorphic $\lambda$-calculus that features inductive types and that enforces termination of recursive definitions through typing. Then, we define a sound and complete type inference algorithm that computes a set of constraints to be satisfied for terms to be typable. In addition, we show that Subject Reduction fails in a naive use of typed-based termination for a $\lambda$-calculus {\`a} la Church, and we propose a general solution to this problem.",
isbn="978-3-540-32014-2"
}

@INPROCEEDINGS{omega,
author={W. {Pugh}},
booktitle={Supercomputing '91:Proceedings of the 1991 ACM/IEEE Conference on Supercomputing},
title={The {Omega} test: A fast and practical integer programming algorithm for dependence analysis},
year={1991},
volume={},
number={},
pages={4-13},
abstract={The Omega test is an integer programming algorithm that can determine whether a dependence exists between two array references, and if so, under what conditions. Conventional wisdom holds that integer programming techniques are far too expensive to be used for dependence analysis, except as a method of last resort for situations that cannot be decided by simpler methods. We present evidence that suggests this wisdom is wrong, and that the Omega test is competitive with approximate algorithms used in practice and suitable for use in production compilers. The Omega test is based on an extension of FourierMotzkin variable elimination to integer programming, and has worst-case exponential time complexity. However, we show that for many situations in which other (polynomial) methods are accurate, the Omega test has low order polynomial time complexity. The Omega test can be used to simplify integer programming problems, rather than just deciding them. This has many applications, including accurately and efficiently computing dependence direction and distance vectors.},
keywords={Testing;Linear programming;Algorithm design and analysis;Production;Polynomials;Vectors;Workstations;NP-complete problem;Software tools},
doi={10.1145/125826.125848},
ISSN={},
month={Nov},}

@inproceedings{miniagda,
author = {Abel, Andreas},
year = {2010},
month = {12},
pages = {14-28},
title = {{MiniAgda}: Integrating Sized and Dependent Types},
volume = {43},
booktitle = {Electronic Proceedings in Theoretical Computer Science},
doi = {10.4204/EPTCS.43.2}
}

@inproceedings{coinductive,
 author = {Sacchini, Jorge Luis},
 title = {Type-Based Productivity of Stream Definitions in the Calculus of Constructions},
 booktitle = {Proceedings of the 2013 28th Annual ACM/IEEE Symposium on Logic in Computer Science},
 series = {LICS '13},
 year = {2013},
 isbn = {978-0-7695-5020-6},
 pages = {233--242},
 numpages = {10},
 url = {https://doi-org.ezproxy.library.ubc.ca/10.1109/LICS.2013.29},
 doi = {10.1109/LICS.2013.29},
 acmid = {2591408},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 keywords = {Type-Based Productivity, Dependent Types, Coinduction, Strong Normalization},
}

@InProceedings{sizedproducts,
author="Barthe, Gilles
and Gr{\'e}goire, Benjamin
and Riba, Colin",
editor="Kaminski, Michael
and Martini, Simone",
title="Type-Based Termination with Sized Products",
booktitle="Computer Science Logic",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="493--507",
abstract="Type-based termination is a semantically intuitive method that ensures termination of recursive definitions by tracking the size of datatype elements, and by checking that recursive calls operate on smaller arguments. However, many systems using type-based termination rely on a semantical anomaly to guarantee strong normalization; namely, they impose that non-recursive elements of a datatype, e.g. the empty list, have size 1 instead of 0. This semantical anomaly also prevents functions such as quicksort to be given a precise typing.",
isbn="978-3-540-87531-4"
}

@Article{calculating-sized-types,
author="Chin, Wei-Ngan
and Khoo, Siau-Cheng",
title="Calculating Sized Types",
journal="Higher-Order and Symbolic Computation",
year="2001",
month="Sep",
day="01",
volume="14",
number="2",
pages="261--300",
abstract="Many program optimizations and analyses, such as array-bounds checking, termination analysis, etc., depend on knowing the size of a function's input and output. However, size information can be difficult to compute. Firstly, accurate size computation requires detecting a size relation between different inputs of a function. Secondly, different optimizations and analyses may require slightly different size information, and thus slightly different computation. Literature in size computation has mainly concentrated on size checking, instead of size inference. In this paper, we provide a generic framework on which different size variants can be expressed and computed. We also describe an effective algorithm for inferring, instead of checking, size information. Size information are expressed in terms of Presburger formulae, and our algorithm utilizes the Omega Calculator to compute as exact a size information as possible, within the linear arithmetic capability.",
issn="1573-0557",
doi="10.1023/A:1012996816178",
url="https://doi.org/10.1023/A:1012996816178"
}